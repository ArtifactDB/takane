<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>takane: takane Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">takane
   </div>
   <div id="projectbrief">Validators for ArtifactDB file formats</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">takane Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><b>takane</b> validation functions.  
<a href="namespacetakane.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetakane_1_1atomic__vector"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1atomic__vector.html">atomic_vector</a></td></tr>
<tr class="memdesc:namespacetakane_1_1atomic__vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for atomic vectors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1bam__file"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1bam__file.html">bam_file</a></td></tr>
<tr class="memdesc:namespacetakane_1_1bam__file"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for BAM files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1bcf__file"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1bcf__file.html">bcf_file</a></td></tr>
<tr class="memdesc:namespacetakane_1_1bcf__file"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for BCF files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1bed__file"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1bed__file.html">bed_file</a></td></tr>
<tr class="memdesc:namespacetakane_1_1bed__file"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for BED files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1bigbed__file"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1bigbed__file.html">bigbed_file</a></td></tr>
<tr class="memdesc:namespacetakane_1_1bigbed__file"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for bigBed files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1bigwig__file"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1bigwig__file.html">bigwig_file</a></td></tr>
<tr class="memdesc:namespacetakane_1_1bigwig__file"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for bigWig files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1compressed__sparse__matrix"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1compressed__sparse__matrix.html">compressed_sparse_matrix</a></td></tr>
<tr class="memdesc:namespacetakane_1_1compressed__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for compressed sparse matrices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1csv__data__frame"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1csv__data__frame.html">csv_data_frame</a></td></tr>
<tr class="memdesc:namespacetakane_1_1csv__data__frame"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for CSV data frames. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1data__frame__factor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1data__frame__factor.html">data_frame_factor</a></td></tr>
<tr class="memdesc:namespacetakane_1_1data__frame__factor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for data frame factors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1delayed__array"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1delayed__array.html">delayed_array</a></td></tr>
<tr class="memdesc:namespacetakane_1_1delayed__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for delayed arrays. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1dense__array"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1dense__array.html">dense_array</a></td></tr>
<tr class="memdesc:namespacetakane_1_1dense__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for dense arrays. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1fasta__file"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1fasta__file.html">fasta_file</a></td></tr>
<tr class="memdesc:namespacetakane_1_1fasta__file"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for FASTA files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1fastq__file"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1fastq__file.html">fastq_file</a></td></tr>
<tr class="memdesc:namespacetakane_1_1fastq__file"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for FASTQ files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1genomic__ranges"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1genomic__ranges.html">genomic_ranges</a></td></tr>
<tr class="memdesc:namespacetakane_1_1genomic__ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for genomic ranges. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1gff__file"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1gff__file.html">gff_file</a></td></tr>
<tr class="memdesc:namespacetakane_1_1gff__file"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for GFF files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1gmt__file"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1gmt__file.html">gmt_file</a></td></tr>
<tr class="memdesc:namespacetakane_1_1gmt__file"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for GMT files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1multi__sample__dataset"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1multi__sample__dataset.html">multi_sample_dataset</a></td></tr>
<tr class="memdesc:namespacetakane_1_1multi__sample__dataset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for multi-sample datasets. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1ranged__summarized__experiment"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1ranged__summarized__experiment.html">ranged_summarized_experiment</a></td></tr>
<tr class="memdesc:namespacetakane_1_1ranged__summarized__experiment"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for ranged summarized experiments. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1sequence__information"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1sequence__information.html">sequence_information</a></td></tr>
<tr class="memdesc:namespacetakane_1_1sequence__information"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for sequence information objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1sequence__string__set"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1sequence__string__set.html">sequence_string_set</a></td></tr>
<tr class="memdesc:namespacetakane_1_1sequence__string__set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for sequence string sets. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1simple__list"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1simple__list.html">simple_list</a></td></tr>
<tr class="memdesc:namespacetakane_1_1simple__list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for simple lists. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1single__cell__experiment"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1single__cell__experiment.html">single_cell_experiment</a></td></tr>
<tr class="memdesc:namespacetakane_1_1single__cell__experiment"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for single cell experiments. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1spatial__experiment"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1spatial__experiment.html">spatial_experiment</a></td></tr>
<tr class="memdesc:namespacetakane_1_1spatial__experiment"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for spatial experiments. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1string__factor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1string__factor.html">string_factor</a></td></tr>
<tr class="memdesc:namespacetakane_1_1string__factor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for string factors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1summarized__experiment"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1summarized__experiment.html">summarized_experiment</a></td></tr>
<tr class="memdesc:namespacetakane_1_1summarized__experiment"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for summarized experiments. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetakane_1_1vcf__experiment"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane_1_1vcf__experiment.html">vcf_experiment</a></td></tr>
<tr class="memdesc:namespacetakane_1_1vcf__experiment"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for VCF experiments. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtakane_1_1CsvContents.html">CsvContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contents of the parsed CSV.  <a href="structtakane_1_1CsvContents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtakane_1_1CsvFieldCreator.html">CsvFieldCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code>comservatory::Field</code> objects to capture column contents.  <a href="structtakane_1_1CsvFieldCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtakane_1_1DummyCsvFieldCreator.html">DummyCsvFieldCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy column creator.  <a href="structtakane_1_1DummyCsvFieldCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object metadata, including the type and other fields.  <a href="structtakane_1_1ObjectMetadata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtakane_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validation options.  <a href="structtakane_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abf51161213924a21c2488c9c4559ebcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#abf51161213924a21c2488c9c4559ebcd">derived_from</a> (const std::string &amp;type, const std::string &amp;base, const <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:abf51161213924a21c2488c9c4559ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f911c69fd6b91281ffb13b4e4aaa9ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a9f911c69fd6b91281ffb13b4e4aaa9ed">dimensions</a> (const std::filesystem::path &amp;path, const <a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a> &amp;metadata, <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a9f911c69fd6b91281ffb13b4e4aaa9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d30c57889066dd97d3726f8b0caddc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a38d30c57889066dd97d3726f8b0caddc">dimensions</a> (const std::filesystem::path &amp;path, <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a38d30c57889066dd97d3726f8b0caddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c436fa62cca35c131e5e35384e8819"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a75c436fa62cca35c131e5e35384e8819">dimensions</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="separator:a75c436fa62cca35c131e5e35384e8819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084412a3641ad26d8cac6de77ad31038"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a084412a3641ad26d8cac6de77ad31038">height</a> (const std::filesystem::path &amp;path, const <a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a> &amp;metadata, <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a084412a3641ad26d8cac6de77ad31038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bab475dda11e075be65248a95d1990"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a03bab475dda11e075be65248a95d1990">height</a> (const std::filesystem::path &amp;path, <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a03bab475dda11e075be65248a95d1990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a148d13def52648b5f7733ede8dc6e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a86a148d13def52648b5f7733ede8dc6e">height</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="separator:a86a148d13def52648b5f7733ede8dc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2190a85cc82ba126b3a834ed1a1b0516"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a2190a85cc82ba126b3a834ed1a1b0516">satisfies_interface</a> (const std::string &amp;type, const std::string &amp;interface, const <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a2190a85cc82ba126b3a834ed1a1b0516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d957cd7981863fed73738d0b0cf6531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a5d957cd7981863fed73738d0b0cf6531">validate</a> (const std::filesystem::path &amp;path, const <a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a> &amp;metadata, <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a5d957cd7981863fed73738d0b0cf6531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15afe9d0c3581409a84c3274aa12567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#aa15afe9d0c3581409a84c3274aa12567">validate</a> (const std::filesystem::path &amp;path, <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:aa15afe9d0c3581409a84c3274aa12567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4dfc3dc5ee51fa250ff1a3fe5169b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a1c4dfc3dc5ee51fa250ff1a3fe5169b4">validate</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="separator:a1c4dfc3dc5ee51fa250ff1a3fe5169b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6711d9cf4ba4e408c1890914ad84b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#aeb6711d9cf4ba4e408c1890914ad84b2">reformat_object_metadata</a> (millijson::Base *raw)</td></tr>
<tr class="separator:aeb6711d9cf4ba4e408c1890914ad84b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4202d62d10c0d3d6ad07085f01736372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetakane.html#a4202d62d10c0d3d6ad07085f01736372">read_object_metadata</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="separator:a4202d62d10c0d3d6ad07085f01736372"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><b>takane</b> validation functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abf51161213924a21c2488c9c4559ebcd" name="abf51161213924a21c2488c9c4559ebcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf51161213924a21c2488c9c4559ebcd">&#9670;&#160;</a></span>derived_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool takane::derived_from </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check whether a particular object type is derived from a base object type. Derived types satisfy the same file requirements of the base type, but usually add more files to represent additional functionality. This can be used by specifications to check whether arbitrary objects satisfy the file structure expectations for a particular base type.</p>
<p >Applications can add their own derived types for a given base class in <code><a class="el" href="structtakane_1_1Options.html#a7d8b3bc37a1544eff48798b06a33b386">Options::custom_derived_from</a></code>. This extends the default relationships whereby <code><a class="el" href="namespacetakane.html#abf51161213924a21c2488c9c4559ebcd">derived_from()</a></code> will take the union of all derived object types in the default and custom sets. Note that derived types must be manually included in every base type's set, e.g., if B is derived from A and C is derived from B, C must be added to the sets for both A and B.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Object type. </td></tr>
    <tr><td class="paramname">base</td><td>Base object type. </td></tr>
    <tr><td class="paramname">options</td><td>Validation options, containing custom derived/base relationships. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>type</code> is derived from <code>base</code> or is equal to <code>base</code>. </dd></dl>

</div>
</div>
<a id="a75c436fa62cca35c131e5e35384e8819" name="a75c436fa62cca35c131e5e35384e8819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c436fa62cca35c131e5e35384e8819">&#9670;&#160;</a></span>dimensions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; takane::dimensions </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Overload of <code><a class="el" href="namespacetakane.html#a9f911c69fd6b91281ffb13b4e4aaa9ed">dimensions()</a></code> with default settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory containing an object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object's dimensions. </dd></dl>

</div>
</div>
<a id="a9f911c69fd6b91281ffb13b4e4aaa9ed" name="a9f911c69fd6b91281ffb13b4e4aaa9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f911c69fd6b91281ffb13b4e4aaa9ed">&#9670;&#160;</a></span>dimensions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; takane::dimensions </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a> &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtakane_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the dimensions of a multi-dimensional object in a subdirectory, based on the supplied object type.</p>
<p >Applications can supply custom dimension functions for a given type via <code><a class="el" href="structtakane_1_1Options.html#a627a97a5ca7a102246602baab3909906">Options::custom_dimensions</a></code>. If available, the supplied custom function will be used instead of the default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory representing an object. </td></tr>
    <tr><td class="paramname">metadata</td><td>Metadata for the object, typically determined from its <code>OBJECT</code> file. </td></tr>
    <tr><td class="paramname">options</td><td>Validation options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the object's dimensions. </dd></dl>

</div>
</div>
<a id="a38d30c57889066dd97d3726f8b0caddc" name="a38d30c57889066dd97d3726f8b0caddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d30c57889066dd97d3726f8b0caddc">&#9670;&#160;</a></span>dimensions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; takane::dimensions </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtakane_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the dimensions of an object in a subdirectory, using its <code>OBJECT</code> file to automatically determine the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory containing an object. </td></tr>
    <tr><td class="paramname">options</td><td>Validation options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object's dimensions. </dd></dl>

</div>
</div>
<a id="a86a148d13def52648b5f7733ede8dc6e" name="a86a148d13def52648b5f7733ede8dc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a148d13def52648b5f7733ede8dc6e">&#9670;&#160;</a></span>height() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t takane::height </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Overload of <code><a class="el" href="namespacetakane.html#a084412a3641ad26d8cac6de77ad31038">height()</a></code> with default settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory containing an object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object's height. </dd></dl>

</div>
</div>
<a id="a084412a3641ad26d8cac6de77ad31038" name="a084412a3641ad26d8cac6de77ad31038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084412a3641ad26d8cac6de77ad31038">&#9670;&#160;</a></span>height() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t takane::height </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a> &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtakane_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the height of an object in a subdirectory, based on the supplied object type.</p>
<p ><code><a class="el" href="namespacetakane.html#a084412a3641ad26d8cac6de77ad31038">height()</a></code> is used to check the shape of objects stored in vertical containers, e.g., columns of a <code>data_frame</code>. For vectors or other 1-dimensional objects, the height is usually just the length of the object (for some object-specific definition of "length"). For higher-dimensional objects, the height is usually the extent of the first dimension.</p>
<p >Applications can supply custom height functions for a given type via <code><a class="el" href="structtakane_1_1Options.html#a321321c382dea1b04b415f9f3c86f727">Options::custom_height</a></code>. If available, the supplied custom function will be used instead of the default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory representing an object. </td></tr>
    <tr><td class="paramname">metadata</td><td>Metadata for the object, typically determined from its <code>OBJECT</code> file. </td></tr>
    <tr><td class="paramname">options</td><td>Validation options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object's height. </dd></dl>

</div>
</div>
<a id="a03bab475dda11e075be65248a95d1990" name="a03bab475dda11e075be65248a95d1990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bab475dda11e075be65248a95d1990">&#9670;&#160;</a></span>height() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t takane::height </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtakane_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the height of an object in a subdirectory, using its <code>OBJECT</code> file to automatically determine the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory containing an object. </td></tr>
    <tr><td class="paramname">options</td><td>Validation options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object's height. </dd></dl>

</div>
</div>
<a id="a4202d62d10c0d3d6ad07085f01736372" name="a4202d62d10c0d3d6ad07085f01736372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4202d62d10c0d3d6ad07085f01736372">&#9670;&#160;</a></span>read_object_metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a> takane::read_object_metadata </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the <code>OBJECT</code> file inside a directory to determine the object type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory containing an object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object metadata, including the type and other fields. </dd></dl>

</div>
</div>
<a id="aeb6711d9cf4ba4e408c1890914ad84b2" name="aeb6711d9cf4ba4e408c1890914ad84b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6711d9cf4ba4e408c1890914ad84b2">&#9670;&#160;</a></span>reformat_object_metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a> takane::reformat_object_metadata </td>
          <td>(</td>
          <td class="paramtype">millijson::Base *&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Parses a JSON object to obtain the object metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>Raw JSON object, typically obtained by <code>millijson::parse_file</code>. Note that <code>raw</code> is consumed by this function and should no longer be used by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object metadata, including the type and other fields. </dd></dl>

</div>
</div>
<a id="a2190a85cc82ba126b3a834ed1a1b0516" name="a2190a85cc82ba126b3a834ed1a1b0516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2190a85cc82ba126b3a834ed1a1b0516">&#9670;&#160;</a></span>satisfies_interface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool takane::satisfies_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtakane_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check whether a particular object type satisfies a particular object interface. This can be used by specifications to check that child components satisfy certain user-level expectations for an abstract object (e.g., data frames, lists).</p>
<p >Applications can extend the <b>takane</b> framework by adding custom types to <code><a class="el" href="structtakane_1_1Options.html#a2cec04779533c0397f05e38c5bf9d226">Options::custom_satisfies_interface</a></code>. This extends the default relationships whereby <code><a class="el" href="namespacetakane.html#a2190a85cc82ba126b3a834ed1a1b0516">satisfies_interface()</a></code> will take the union of all object types in the default and custom sets. Note that, if a type is included in a particular set, it is not necessary to add its derived types, as <code><a class="el" href="namespacetakane.html#a2190a85cc82ba126b3a834ed1a1b0516">satisfies_interface()</a></code> will automatically call <code><a class="el" href="namespacetakane.html#abf51161213924a21c2488c9c4559ebcd">derived_from()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Object type. </td></tr>
    <tr><td class="paramname">interface</td><td>Interface type. </td></tr>
    <tr><td class="paramname">options</td><td>Validation options, containing custom object interface relationships. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>type</code> satisfies <code>interface</code>. </dd></dl>

</div>
</div>
<a id="a1c4dfc3dc5ee51fa250ff1a3fe5169b4" name="a1c4dfc3dc5ee51fa250ff1a3fe5169b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4dfc3dc5ee51fa250ff1a3fe5169b4">&#9670;&#160;</a></span>validate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void takane::validate </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Overload of <code><a class="el" href="namespacetakane.html#a5d957cd7981863fed73738d0b0cf6531">validate()</a></code> with default settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory containing an object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d957cd7981863fed73738d0b0cf6531" name="a5d957cd7981863fed73738d0b0cf6531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d957cd7981863fed73738d0b0cf6531">&#9670;&#160;</a></span>validate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void takane::validate </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtakane_1_1ObjectMetadata.html">ObjectMetadata</a> &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtakane_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Validate an object in a subdirectory, based on the supplied object type.</p>
<p >Applications can supply custom validation functions for a given type via <code><a class="el" href="structtakane_1_1Options.html#af7a851d46a6a1795a461640f44bd3220">Options::custom_validate</a></code>. If available, the supplied custom function will be used instead of the default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory representing an object. </td></tr>
    <tr><td class="paramname">metadata</td><td>Metadata for the object, typically determined from its <code>OBJECT</code> file. </td></tr>
    <tr><td class="paramname">options</td><td>Validation options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa15afe9d0c3581409a84c3274aa12567" name="aa15afe9d0c3581409a84c3274aa12567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15afe9d0c3581409a84c3274aa12567">&#9670;&#160;</a></span>validate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void takane::validate </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtakane_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Validate an object in a subdirectory, using its <code>OBJECT</code> file to automatically determine the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a directory containing an object. </td></tr>
    <tr><td class="paramname">options</td><td>Validation options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
