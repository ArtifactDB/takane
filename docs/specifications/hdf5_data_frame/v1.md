# HDF5 data frame

## Overview

A data frame object stored inside a group of a HDF5 file, corresponding to the [`hdf5_data_frame`](https://github.com/ArtifactDB/BiocObjectSchemas/raw/master/raw/hdf5_data_frame/v1.json) schema.
We use `~` below to refer to properties of the schema.

The name of the group is specified in the `~hdf5_data_frame.group` property. 
Each atomic column is stored as a 1-dimensional dataset in the `data` subgroup, named by its positional 0-based index in the data frame,
e.g., the first column is named `0`, the second column is named `1`, and so on.
All datasets representing atomic columns should have the same length.
The type of each atomic column is determined from the corresponding `~data_frame.columns.type` property in the schema:

- A boolean column is stored as an integer HDF5 dataset where a value of 1 is truthy and a value of zero is falsey.
  Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer.
- An integer column can be represented by any integer HDF5 dataset.
  Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer.
- A factor column has some version-dependent treatment:
  - **For `~data_frame.version >= 2`:** A factor column is represented by a integer HDF5 dataset.
    Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer.
    Each integer is a 0-based index into the array of factor levels, found in the `~data_frame.columns.levels` property.
    Each integer should be non-negative and less than the total number of levels, or equal to the missing value placeholder (see below).
  - **For `~data_frame.version = 1`:** A factor column is represented by any string dataset.
    Each entry in the string dataset should either be present in the set of levels or be equal to the missing placeholder value (see below).
- A number columns has some version-dependent treatment:
  - **For `~hdf5_data_frame.version >= 3`:** A floating-point column can be represented by any integer or floating-point dataset.
    IEEE754 special values like Inf and NaN are allowed.
    Any integer or floating-point data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 64-bit IEEE754-compliant float.
    See the [HDF5 policy draft (0.1.0)](https://github.com/ArtifactDB/Bioc-HDF5-policy/tree/0.1.0) for more details.
  - **For `~hdf5_data_frame.version < 3`:** A floating-point column can be represented by any floating-point dataset.
    IEEE754 special values like Inf and NaN are allowed.
- String columns can be represented by any string datatype (fixed or variable, ASCII or UTF-8) at the discretion of the data generator.
  The character encoding specified in the dataset's type should be respected.
  Non-missing strings may be associated with further format constraints based on the `~data_frame.columns.format` property, which may be one of the following:
  - No format constraints.
  - String must be a `YYYY-MM-DD` date.
  - String must be an Internet date/time complying with the RFC3339 specification.

For non-atomic columns, the corresponding dataset is omitted and the actual contents are obtained from other files.
A pointer to the resource should be stored in the corresponding entry of the `~data_frame.columns` property.

Column names are stored in `column_names`, a 1-dimensional string dataset of length equal to the number of columns.
All column names should be unique and no missing values should be present.

If `~data_frame.row_names = true`, row names should be stored in a 1-dimensional `row_names` string dataset of the same length at the number of rows.
No missing values should be present.

## Missing values

The treatment of missing values is version-dependent:

- **For `~hdf5_data_frame.version >= 3`:** 
  each dataset may have a `missing-value-placeholder` attribute, containing a scalar value.
  Any value in the dataset equal to this placeholder should be treated as missing.
  For all types except strings, the type of the scalar should b exactly the same as that of the dataset, so as to avoid transformations during casting.
  For strings, the scalar value may be of any string type class, and all comparisons should be performed byte-wise like `strcmp`.
  For numbers, the scalar value may be NaN, in which case all NaNs in the dataset are treated as missing regardless of the payload.
  If no attribute exists, it can be assumed that no values are missing.
  See the [HDF5 policy draft (0.1.0)](https://github.com/ArtifactDB/Bioc-HDF5-policy/tree/0.1.0) for more details.
- **For `~hdf5_data_frame.version = 2`:** 
  each dataset may have a `missing-value-placeholder` attribute, containing a scalar value.
  Any value in the dataset equal to this placeholder should be treated as missing.
  For all types except strings, the type of the scalar should b exactly the same as that of the dataset, so as to avoid transformations during casting.
  For strings, the scalar value may be of any string type class, and all comparisons should be performed byte-wise like `strcmp`.
  For numbers, the scalar value may be NaN with a non-default payload, which should be considered via byte-wise comparisons, e.g., with `memcmp`.
  If no attribute exists, it can be assumed that no values are missing.
- **For `~hdf5_data_frame.version = 1`:** 
  missing integers and booleans are represented by -2147483648. 
  Missing floats are always represented by NaNs with R's missingness payload.
  Missing strings are represented by a `missing-value-placeholder` attribute, containing a scalar value of some string type.

## Example usage

Here we validate a HDF5 data frame with columns of different types and row names:

```cpp
#include "takane/takane.hpp"

std::vector<takane::data_frame::ColumnDetails> expected_columns(5);
expected_columns[0].type = takane::data_frame::ColumnType::INTEGER;
expected_columns[1].type = takane::data_frame::ColumnType::STRING;
expected_columns[2].type = takane::data_frame::ColumnType::STRING;
expected_columns[2].format = takane::data_frame::StringFormat::DATETIME;
expected_columns[3].type = takane::data_frame::ColumnType::FACTOR;
expected_columns[3].add_factor_level("foo"); // taken from 'data_frame.columns[3].levels'
expected_columns[3].add_factor_level("bar");
expected_columns[4].type = takane::data_frame::ColumnType::NUMBER;

takane::hdf5_data_frame::Parameters params;
params.group = group_name;
params.num_rows = 9876;
params.has_row_names = true;
params.columns = &expected_columns; // can also pass by value here.

takane::hdf5_data_frame::validate(path, params);
```
