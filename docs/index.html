<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>takane: Miscellaneous validators for ArtifactDB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">takane
   </div>
   <div id="projectbrief">Validators for ArtifactDB file formats</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Miscellaneous validators for ArtifactDB </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md__github_workspace_README"></a> </p><h1>Overview</h1>
<p >This library contains some C++ libraries to validate ArtifactDB file formats that aren't covered by other libraries (e.g., <a href="https://github.com/ArtifactDB/comservatory"><b>comservatory</b></a>, <a href="https://github.com/ArtifactDB/uzuki2"><b>uzuki2</b></a>). The idea is to provide a cross-language method for validating the files - which is not quite as useful as a library for <em>reading</em> the files, but it's better than nothing.</p>
<h1>Specifications</h1>
<h2>HDF5 data frame</h2>
<p >A data frame object stored inside a group of a HDF5 file. This corresponds to the <a href="https://github.com/ArtifactDB/BiocObjectSchemas/raw/master/raw/hdf5_data_frame/v1.json"><code>hdf5_data_frame</code></a> schema, of which several properties are worth noting:</p>
<ul>
<li>The name of the group is specified in the <code>hdf5_data_frame.group</code> property.</li>
<li>The <code>data_frame.version</code> property has a maximum value of 2.</li>
<li>The <code>hdf5_data_frame.version</code> property has a maximum value of 2.</li>
</ul>
<p >Each atomic column is stored as a 1-dimensional dataset in the <code>data</code> subgroup, named by its positional 0-based index in the data frame, e.g., the first column is named <code>0</code>, the second column is named <code>1</code>, and so on. All datasets representing atomic columns should have the same length. The type of each atomic column is determined from the corresponding <code>data_frame.columns.type</code> property in the schema:</p>
<ul>
<li>A boolean column is stored as an integer HDF5 dataset where a value of 1 is truthy and a value of zero is falsey. Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer.</li>
<li>An integer column can be represented by any integer HDF5 dataset. Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer.</li>
<li><b>For <code>data_frame.version &gt;= 2</code>:</b> A factor column is represented by a integer HDF5 dataset. Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer. Each integer is a 0-based index into the array of factor levels, found in the <code>data_frame.columns.levels</code> property. Each integer should be non-negative and less than the total number of levels, or equal to the missing value placeholder (see below).</li>
<li><b>For <code>data_frame.version = 1</code>:</b> A factor column is represented by any string dataset. Each entry in the string dataset should either be present in the set of levels or be equal to the missing placeholder value (see below).</li>
<li>Floating-point columns can be represented by any floating-point datatype at the discretion of the data generator. IEEE special values like Inf and NaN are allowed.</li>
<li>String columns can be represented by any string datatype (fixed or variable, ASCII or UTF-8) at the discretion of the data generator. The character encoding specified in the dataset's type should be respected. Non-missing strings may be associated with further format constraints based on the <code>data_frame.columns.format</code> property, which may be one of the following:<ul>
<li>No format constraints.</li>
<li>String must be a <code>YYYY-MM-DD</code> date.</li>
<li>String must be an Internet date/time complying with the RFC3339 specification.</li>
</ul>
</li>
</ul>
<p ><b>For <code>hdf5_data_frame.version &gt;= 2</code>:</b> Each dataset may have a <code>missing-value-placeholder</code> attribute, containing a scalar value of the same exact type. Any value in the dataset equal to this placeholder should be treated as missing. If no attribute exists, it can be assumed that no values are missing. For all types except strings, the type of the scalar should b exactly the same as that of the dataset, so as to avoid transformations during casting. For strings, the scalar value may be of any string type class, and all comparisons should be performed byte-wise like <code>strcmp</code>. For numbers, the scalar value may be NaN with a non-default payload, which should be considered via byte-wise comparisons, e.g., with <code>memcmp</code>.</p>
<p ><b>For <code>hdf5_data_frame.version = 1</code>:</b> Missing integers and booleans are represented by -2147483648. Missing floats are always represented by NaNs with R's missingness payload. Missing strings are represented by a <code>missing-value-placeholder</code> attribute, containing a scalar value of some string type.</p>
<p >For non-atomic columns, the corresponding dataset is omitted and the actual contents are obtained from other files. A pointer to the resource should be stored in the corresponding entry of the <code>data_frame.columns</code> property.</p>
<p >Column names are stored in <code>column_names</code>, a 1-dimensional string dataset of length equal to the number of columns. Row names, if present, are stored in a 1-dimensional <code>row_names</code> string dataset of the same length at the number of rows. Neither should contain any missing values.</p>
<details >
<p ><summary>Example usage</summary></p>
<p >Here we validate a HDF5 data frame with columns of different types and row names:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;takane/takane.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;takane::data_frame::ColumnDetails&gt; expected_columns(5);</div>
<div class="line">expected_columns[0].type = takane::data_frame::ColumnType::INTEGER;</div>
<div class="line">expected_columns[1].type = takane::data_frame::ColumnType::STRING;</div>
<div class="line">expected_columns[2].type = takane::data_frame::ColumnType::STRING;</div>
<div class="line">expected_columns[2].format = takane::data_frame::StringFormat::DATETIME;</div>
<div class="line">expected_columns[3].type = takane::data_frame::ColumnType::FACTOR;</div>
<div class="line">expected_columns[3].add_factor_level(<span class="stringliteral">&quot;foo&quot;</span>); <span class="comment">// taken from &#39;data_frame.columns[3].levels&#39;</span></div>
<div class="line">expected_columns[3].add_factor_level(<span class="stringliteral">&quot;bar&quot;</span>);</div>
<div class="line">expected_columns[4].type = takane::data_frame::ColumnType::NUMBER;</div>
<div class="line"> </div>
<div class="line">takane::data_frame::validate_hdf5(</div>
<div class="line">    path, </div>
<div class="line">    name, </div>
<div class="line">    <span class="comment">/* num_rows = */</span> 9876, </div>
<div class="line">    <span class="comment">/* has_row_names = */</span> <span class="keyword">true</span>, </div>
<div class="line">    <span class="comment">/* columns = */</span> expected_columns,</div>
<div class="line">    <span class="comment">/* options = */</span> comservatory::ReadOptions()</div>
<div class="line">);</div>
</div><!-- fragment --> </details>
<h2>CSV data frame</h2>
<p >A data frame object stored inside a CSV file, formatted as described in the <a href="https://github.com/ArtifactDB/comservatory"><b>comservatory</b> specification (version 1.0)</a>. This corresponds to the <a href="https://github.com/ArtifactDB/BiocObjectSchemas/raw/master/raw/csv_data_frame/v1.json"><code>csv_data_frame</code></a> schema, of which several properties are worth noting:</p>
<ul>
<li>The <code>data_frame.version</code> property has a maximum value of 2.</li>
</ul>
<p >The type of each column is determined from the corresponding <code>data_frame.columns.type</code> property in the schema:</p>
<ul>
<li>Boolean columns are stored as <b>comservatory</b> boolean columns.</li>
<li>Number columns are stored as <b>comservatory</b> number columns.</li>
<li>An integer column is stored as a <b>comservatory</b> integer column, where all (non-missing) values must be representable by a 32-bit signed integer.</li>
<li><b>For <code>data_frame.version &gt;= 2</code>:</b> A factor column is represented as a <b>comservatory</b> integer column containing 0-based indices into the array of levels. All (non-missing) values are non-negative and less than the total number of levels.</li>
<li><b>For <code>data_frame.version = 1</code>:</b> A factor column is represented as a <b>comservatory</b> string dataset. Each (non-missing) entry in the string dataset should either be present in the set of levels or be equal to the missing placeholder value (see below).</li>
<li>String columns are stored as <b>comservatory</b> string columns. Strings may be associated with further format constraints based on the <code>data_frame.columns.format</code> property, which may be one of the following:<ul>
<li>No format constraints.</li>
<li>String must be a <code>YYYY-MM-DD</code> date.</li>
<li>String must be an Internet date/time complying with the RFC3339 specification.</li>
</ul>
</li>
</ul>
<p >For non-atomic columns, a placeholder column should be present in the CSV. This placeholder may be of any type as it will be ignored by readers.</p>
<p >If row names are present, they should be present in the first column of the CSV as strings. All row names should be non-missing.</p>
<details >
<p ><summary>Example usage</summary></p>
<p >Here we validate a CSV data frame with columns of different types and row names:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;takane/takane.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;takane::data_frame::ColumnDetails&gt; expected_columns(5);</div>
<div class="line">expected_columns[0].type = takane::data_frame::ColumnType::INTEGER;</div>
<div class="line">expected_columns[1].type = takane::data_frame::ColumnType::STRING;</div>
<div class="line">expected_columns[2].type = takane::data_frame::ColumnType::STRING;</div>
<div class="line">expected_columns[2].format = takane::data_frame::StringFormat::DATETIME;</div>
<div class="line">expected_columns[3].type = takane::data_frame::ColumnType::FACTOR;</div>
<div class="line">expected_columns[3].add_factor_level(<span class="stringliteral">&quot;foo&quot;</span>); <span class="comment">// taken from &#39;data_frame.columns[3].levels&#39;</span></div>
<div class="line">expected_columns[3].add_factor_level(<span class="stringliteral">&quot;bar&quot;</span>);</div>
<div class="line">expected_columns[4].type = takane::data_frame::ColumnType::NUMBER;</div>
<div class="line"> </div>
<div class="line">takane::data_frame::validate_csv(</div>
<div class="line">    path, </div>
<div class="line">    <span class="comment">/* num_rows = */</span> 9876, </div>
<div class="line">    <span class="comment">/* has_row_names = */</span> <span class="keyword">true</span>, </div>
<div class="line">    <span class="comment">/* columns = */</span> expected_columns,</div>
<div class="line">    <span class="comment">/* options = */</span> comservatory::ReadOptions()</div>
<div class="line">);</div>
</div><!-- fragment --><p >Note that the row name column does not need to be considered in the set of <code>expected_columns</code>; it is handled separately by the <code>has_row_names = true</code> argument. </p>
</details>
<h2>Genomic ranges</h2>
<p >A <code>GenomicRanges</code> object stored inside a CSV file, formatted as described in the <a href="https://github.com/ArtifactDB/comservatory"><b>comservatory</b> specification (version 1.0)</a>. This corresponds to the <a href="https://github.com/ArtifactDB/BiocObjectSchemas/raw/master/raw/csv_data_frame/v1.json"><code>genomic_ranges</code></a> schema. We expect the columns in the following type and order:</p>
<ul>
<li>(optional) a column of strings containing names for each genomic range. This may have any column name. All strings should be non-missing.</li>
<li>A column named <code>seqnames</code>, containing strings with the reference sequence (e.g., chromosome) name for each genomic range. All strings should be non-missing and belong to the set of known sequences in the corresponding <code>sequence_information</code> object.</li>
<li>A column named <code>start</code>, containing the 1-based start position of each range on its reference sequence. All values are represented by 32-bit signed integers; negative values are allowed. No values should be missing.</li>
<li>A column named <code>end</code>, containing the 1-based end position (inclusive) of each range. All values are represented by 32-bit signed integers; negative values are allowed. No values should be missing. The <code>end</code> value for each range should be greater than or equal to <code>start - 1</code>.</li>
<li>A column named <code>strand</code>, containing the strand of each range. This should be one of the following strings: <code>+</code>, <code>-</code> or <code>*</code>. No values should be missing.</li>
</ul>
<details >
<p ><summary>Example usage</summary></p>
<p >Here we validate a <code>genomic_ranges</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;takane/takane.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line">std::unordered_set&lt;std::string&gt; allowed{ <span class="stringliteral">&quot;chrA&quot;</span>, <span class="stringliteral">&quot;chrB&quot;</span> };</div>
<div class="line"> </div>
<div class="line">takane::genomic_ranges::validate(</div>
<div class="line">    path, </div>
<div class="line">    <span class="comment">/* num_ranges = */</span> 192, </div>
<div class="line">    <span class="comment">/* has_names = */</span> <span class="keyword">true</span>, </div>
<div class="line">    <span class="comment">/* seqnames = */</span> allowed,</div>
<div class="line">    <span class="comment">/* options = */</span> comservatory::ReadOptions()</div>
<div class="line">);</div>
</div><!-- fragment --> </details>
<h1>Building projects</h1>
<h2>CMake with <code>FetchContent</code></h2>
<p >If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  takane </div>
<div class="line">  GIT_REPOSITORY https://github.com/ArtifactDB/takane</div>
<div class="line">  GIT_TAG master # or any version of interest</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(takane)</div>
</div><!-- fragment --><p >Then you can link to <b>takane</b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe takane)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE takane)</div>
</div><!-- fragment --><h2>CMake with <code>find_package()</code></h2>
<p >You can install the library by cloning a suitable version of this repository and running the following commands:</p>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake .. -DTAKANE_TESTS=OFF</div>
<div class="line">cmake --build . --target install</div>
</div><!-- fragment --><p >Then you can use <code>find_package()</code> as usual:</p>
<div class="fragment"><div class="line">find_package(artifactdb_takane CONFIG REQUIRED)</div>
<div class="line">target_link_libraries(mylib INTERFACE artifactdb::takane)</div>
</div><!-- fragment --><h2>Manual</h2>
<p >If you're not using CMake, the simple approach is to just copy the files in the <code>include/</code> subdirectory - either directly or with Git submodules - and include their path during compilation with, e.g., GCC's <code>-I</code>. You will also need to link to the dependencies listed in the <a href="extern/CMakeLists.txt"><code>extern/CMakeLists.txt</code></a> directory along with the HDF5 library.</p>
<h1>Further comments</h1>
<p >This library is named after <a href="https://myanimelist.net/character/40012/Takane_Shijou">Takane Shijou</a>, continuing my trend of naming C++ libraries after <a href="https://myanimelist.net/anime/10278/The_iDOLMSTER">iDOLM@STER</a> characters.</p>
<p ><img src="https://64.media.tumblr.com/17ecbb29ab7ed3328ed854c1b02e0eec/tumblr_o49c7i4jUu1th93f0o1_540.gif" alt="Takane GIF" class="inline"/> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
