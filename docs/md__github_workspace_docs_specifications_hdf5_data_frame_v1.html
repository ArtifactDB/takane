<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>takane: HDF5 data frame</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">takane
   </div>
   <div id="projectbrief">Validators for ArtifactDB file formats</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">HDF5 data frame </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Overview</h1>
<p >A data frame object stored inside a group of a HDF5 file, corresponding to the <a href="https://github.com/ArtifactDB/BiocObjectSchemas/raw/master/raw/hdf5_data_frame/v1.json"><code>hdf5_data_frame</code></a> schema. We use <code>~</code> below to refer to properties of the schema.</p>
<p >The name of the main group (containing the data frame contents) is specified in the <code>~hdf5_data_frame.group</code> property. This group may have a <code>version</code> property containing a scalar <code>&lt;major&gt;.&lt;minor&gt;</code> version string. If a version attibute is present on <code>group</code>, all version-related properties in the schema (e.g., <code>~data_frame.version</code>, <code>~hdf5_data_frame.version</code>) will be ignored in the remainder of this document.</p>
<p ><b>If a <code>version</code> attribute is present on the main group:</b> the group should contain a <code>row-count</code> integer scalar attribute, containing the number of rows. Any integer datatype can be used as long as it can be represented by a 64-bit unsigned integer. The value should be equal to <code>~data_frame.dimensions[0]</code>.</p>
<p >Each atomic column is stored as a group or 1-dimensional dataset in the <code>data</code> subgroup, named by its positional 0-based index in the data frame, e.g., the first column is named <code>0</code>, the second column is named <code>1</code>, and so on. The type of each atomic column is determined from the corresponding <code>~data_frame.columns.type</code> property in the schema, see below for more details.</p>
<p >For non-atomic columns, the corresponding dataset is omitted and the actual contents are obtained from other files. A pointer to the resource should be stored in the corresponding entry of the <code>~data_frame.columns</code> property.</p>
<p >Column names are stored in <code>column_names</code>, a 1-dimensional string dataset of length equal to the number of columns. All column names should be unique non-empty strings and no missing values should be present.</p>
<p >If <code>~data_frame.row_names = true</code>, row names should be stored in a 1-dimensional <code>row_names</code> string dataset of the same length at the number of rows. No missing values should be present.</p>
<h1>Column types</h1>
<h2>Boolean</h2>
<p >A boolean column is stored as a 1-dimensional integer HDF5 dataset of length equal to the number of rows (i.e., <code>~data_frame.dimensions[0]</code>). A value of zero is considered to be falsey and a non-zero value is truthy. Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer.</p>
<p ><b>If a <code>version</code> attribute is present on the main group:</b> this dataset should have a <code>type</code> scalar string attribute that contains the value <code>"boolean"</code>.</p>
<h2>Integer</h2>
<p >An integer column can be represented by any 1-dimensional integer HDF5 dataset of length equal to <code>~data_frame.dimensions[0]</code>. Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer.</p>
<p ><b>If a <code>version</code> attribute is present on the main group:</b> this dataset should have a <code>type</code> scalar string attribute that contains the value <code>"integer"</code>.</p>
<h2>Number</h2>
<p >A number column is represented by a 1-dimensional HDF5 dataset of length equal to <code>~data_frame.dimensions[0]</code>.</p>
<p ><b>If a <code>version</code> attribute is present on the main group:</b> the column can be represented by any integer or floating-point dataset. IEEE754 special values like Inf and NaN are allowed. Any integer or floating-point data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 64-bit IEEE754-compliant float. See the <a href="https://github.com/ArtifactDB/Bioc-HDF5-policy/tree/0.1.0">HDF5 policy draft (0.1.0)</a> for more details. This dataset should also have a <code>type</code> scalar string attribute that contains the value <code>"number"</code>.</p>
<p ><b>Otherwise:</b> the column can be represented by any floating-point dataset. IEEE754 special values like Inf and NaN are allowed.</p>
<h2>String</h2>
<p >String columns can be represented by any 1-dimensional string HDF5 dataset of length equal to <code>~data_frame.dimensions[0]</code>. Any string datatype may be used (fixed or variable, ASCII or UTF-8) at the discretion of the data generator.</p>
<p >Missing strings are denoted by placeholders, see below for details.</p>
<p >Non-missing strings may be associated with further format constraints based on the <code>~data_frame.columns.format</code> property, which may be one of the following:</p><ul>
<li><code>"none"</code>: no format constraints.</li>
<li><code>"date"</code>: string must be a <code>YYYY-MM-DD</code> date.</li>
<li><code>"date-time"</code>: string must be an Internet date/time complying with the RFC3339 specification.</li>
</ul>
<p ><b>If a <code>version</code> attribute is present on the main group:</b> This dataset should have a <code>type</code> scalar string attribute that contains the value <code>"string"</code>. It may also have a <code>format</code> scalar string attribute that contains one of the allowed formats; this should be identical to <code>~data_frame.columns.format</code> (if the attribute is absent, it is implied to be <code>"none"</code>).</p>
<h2>Factor</h2>
<p ><b>If a <code>version</code> attribute is present on the main group:</b> a factor is represented by a subgroup in <code>data</code> that contains:</p><ul>
<li><code>levels</code>, a 1-dimensional string dataset containing the levels. Any datatype may be used at the discretion of the data generator. All values should be unique, and the total length should be less than 2147483648.</li>
<li><code>codes</code>, a 1-dimensional integer dataset of length equal to <code>~data_frame.dimensions[0]</code>. Each value is a 0-based index into the array of factor levels from <code>levels</code>. Each value should be non-negative and less than the total number of levels, or equal to the missing value placeholder (see below). Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer.</li>
<li><code>type</code>, a scalar string attribute on the subgroup. This should be set to <code>"factor"</code>.</li>
<li>(optional) <code>ordered</code>, an scalar integer attribute on the subgroup indicating whether the factor levels are ordered. This should be consistent with the value of <code>~data_frame.columns.ordered</code> (levels are implied to be unordered in the absence of this attribute).</li>
</ul>
<p ><b>Otherwise:</b> the treatment of factors is determined by <code>~data_frame.version</code>:</p><ul>
<li><b>For <code>~data_frame.version &gt;= 2</code>:</b> A factor column is represented by a 1-dimensional integer HDF5 dataset of length equal to <code>~data_frame.dimensions[0]</code>. Any integer data type can be used at the discretion of the data generator, though the type's range of values must be representable by a 32-bit signed integer. Each integer is a 0-based index into the array of factor levels, found in the <code>~data_frame.columns.levels</code> property. Each integer should be non-negative and less than the total number of levels, or equal to the missing value placeholder (see below).</li>
<li><b>For <code>~data_frame.version = 1</code>:</b> A factor column is represented by any 1-dimensional string dataset of length equal to <code>~data_frame.dimensions[0]</code>. Each entry in the string dataset should either be present in the set of levels or be equal to the missing placeholder value (see below).</li>
</ul>
<h1>Missing values</h1>
<p ><b>If a <code>version</code> attribute is present on the main group:</b> each dataset may have a <code>missing-value-placeholder</code> attribute, containing a scalar value. Any value in the dataset equal to this placeholder should be treated as missing. For all types except strings, the type of the scalar should b exactly the same as that of the dataset, so as to avoid transformations during casting. For strings, the scalar value may be of any string type class, and all comparisons should be performed byte-wise like <code>strcmp</code>. For numbers, the scalar value may be NaN, in which case all NaNs in the dataset are treated as missing regardless of the payload. If no attribute exists, it can be assumed that no values are missing. See the <a href="https://github.com/ArtifactDB/Bioc-HDF5-policy/tree/0.1.0">HDF5 policy draft (0.1.0)</a> for more details.</p>
<p ><b>Otherwise:</b> the handling of missing values is determined by <code>~hdf5_data_frame.version</code>:</p><ul>
<li><b>For <code>~hdf5_data_frame.version = 2</code>:</b> each dataset may have a <code>missing-value-placeholder</code> attribute, containing a scalar value. Any value in the dataset equal to this placeholder should be treated as missing. For all types except strings, the type of the scalar should b exactly the same as that of the dataset, so as to avoid transformations during casting. For strings, the scalar value may be of any string type class, and all comparisons should be performed byte-wise like <code>strcmp</code>. For numbers, the scalar value may be NaN with a non-default payload, which should be considered via byte-wise comparisons, e.g., with <code>memcmp</code>. If no attribute exists, it can be assumed that no values are missing.</li>
<li><b>For <code>~hdf5_data_frame.version = 1</code>:</b> missing integers and booleans are represented by -2147483648. Missing floats are always represented by NaNs with R's missingness payload. Missing strings are represented by a <code>missing-value-placeholder</code> attribute, containing a scalar value of some string type.</li>
</ul>
<h1>Example usage</h1>
<p >Here we validate a HDF5 data frame with columns of different types and row names:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;takane/takane.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;takane::data_frame::ColumnDetails&gt; expected_columns(5);</div>
<div class="line">expected_columns[0].type = takane::data_frame::ColumnType::INTEGER;</div>
<div class="line">expected_columns[1].type = takane::data_frame::ColumnType::STRING;</div>
<div class="line">expected_columns[2].type = takane::data_frame::ColumnType::STRING;</div>
<div class="line">expected_columns[2].format = takane::data_frame::StringFormat::DATETIME;</div>
<div class="line">expected_columns[3].type = takane::data_frame::ColumnType::FACTOR;</div>
<div class="line">expected_columns[3].add_factor_level(<span class="stringliteral">&quot;foo&quot;</span>); <span class="comment">// taken from &#39;data_frame.columns[3].levels&#39;</span></div>
<div class="line">expected_columns[3].add_factor_level(<span class="stringliteral">&quot;bar&quot;</span>);</div>
<div class="line">expected_columns[4].type = takane::data_frame::ColumnType::NUMBER;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structtakane_1_1hdf5__data__frame_1_1Parameters.html">takane::hdf5_data_frame::Parameters</a> params;</div>
<div class="line">params.<a class="code hl_variable" href="structtakane_1_1hdf5__data__frame_1_1Parameters.html#a0d50ca7b49cdcf027b4c8abb45e39b21">group</a> = group_name;</div>
<div class="line">params.<a class="code hl_variable" href="structtakane_1_1hdf5__data__frame_1_1Parameters.html#a5e05ea1e9509a4be79670d5af06512ef">num_rows</a> = 9876;</div>
<div class="line">params.<a class="code hl_variable" href="structtakane_1_1hdf5__data__frame_1_1Parameters.html#a7554cda5388861f2cb5c6e3a1858dff6">has_row_names</a> = <span class="keyword">true</span>;</div>
<div class="line">params.<a class="code hl_variable" href="structtakane_1_1hdf5__data__frame_1_1Parameters.html#a5646b75b9312c62ada2e3a5db28de584">columns</a> = &amp;expected_columns; <span class="comment">// can also pass by value here.</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacetakane_1_1hdf5__data__frame.html#aa339d857191a71baa76517f096bd14fd">takane::hdf5_data_frame::validate</a>(path, params);</div>
<div class="ttc" id="anamespacetakane_1_1hdf5__data__frame_html_aa339d857191a71baa76517f096bd14fd"><div class="ttname"><a href="namespacetakane_1_1hdf5__data__frame.html#aa339d857191a71baa76517f096bd14fd">takane::hdf5_data_frame::validate</a></div><div class="ttdeci">void validate(const H5::H5File &amp;handle, const Parameters &amp;params)</div><div class="ttdef"><b>Definition:</b> hdf5_data_frame.hpp:512</div></div>
<div class="ttc" id="astructtakane_1_1hdf5__data__frame_1_1Parameters_html"><div class="ttname"><a href="structtakane_1_1hdf5__data__frame_1_1Parameters.html">takane::hdf5_data_frame::Parameters</a></div><div class="ttdoc">Parameters for validating the HDF5 data frame.</div><div class="ttdef"><b>Definition:</b> hdf5_data_frame.hpp:32</div></div>
<div class="ttc" id="astructtakane_1_1hdf5__data__frame_1_1Parameters_html_a0d50ca7b49cdcf027b4c8abb45e39b21"><div class="ttname"><a href="structtakane_1_1hdf5__data__frame_1_1Parameters.html#a0d50ca7b49cdcf027b4c8abb45e39b21">takane::hdf5_data_frame::Parameters::group</a></div><div class="ttdeci">std::string group</div><div class="ttdef"><b>Definition:</b> hdf5_data_frame.hpp:41</div></div>
<div class="ttc" id="astructtakane_1_1hdf5__data__frame_1_1Parameters_html_a5646b75b9312c62ada2e3a5db28de584"><div class="ttname"><a href="structtakane_1_1hdf5__data__frame_1_1Parameters.html#a5646b75b9312c62ada2e3a5db28de584">takane::hdf5_data_frame::Parameters::columns</a></div><div class="ttdeci">WrappedOption&lt; std::vector&lt; data_frame::ColumnDetails &gt; &gt; columns</div><div class="ttdef"><b>Definition:</b> hdf5_data_frame.hpp:57</div></div>
<div class="ttc" id="astructtakane_1_1hdf5__data__frame_1_1Parameters_html_a5e05ea1e9509a4be79670d5af06512ef"><div class="ttname"><a href="structtakane_1_1hdf5__data__frame_1_1Parameters.html#a5e05ea1e9509a4be79670d5af06512ef">takane::hdf5_data_frame::Parameters::num_rows</a></div><div class="ttdeci">size_t num_rows</div><div class="ttdef"><b>Definition:</b> hdf5_data_frame.hpp:46</div></div>
<div class="ttc" id="astructtakane_1_1hdf5__data__frame_1_1Parameters_html_a7554cda5388861f2cb5c6e3a1858dff6"><div class="ttname"><a href="structtakane_1_1hdf5__data__frame_1_1Parameters.html#a7554cda5388861f2cb5c6e3a1858dff6">takane::hdf5_data_frame::Parameters::has_row_names</a></div><div class="ttdeci">bool has_row_names</div><div class="ttdef"><b>Definition:</b> hdf5_data_frame.hpp:51</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
